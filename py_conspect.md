# Конспект

## Базовые структуры данных

### Числа

Целые числа **int**

* Деление "на цело" //
* Остаток от деления на цело % (по модулю)
* Возведение в степень **
* Проверка на равенство ==
* Проверка на равенство !=
* Тройное сравнение 3 < 5 < 7 -> true

Вещественные числа **float**
пишутся через ***"точку"***.

Можно писать без *"лидирующего нуля"*     .8734587634583.

При умножении целого на вещественное, результат будет вещественный.

* Функция конвертации:

```
int(3.0) = 3
float(42) = 42.0
```

* Функция округления вещественных чисел по математическим правилам c добавлением знаков после запятой:

```
x = round(a * b, 3)
```

### Строки

Кавычки можно использовать любые.

Тройные одинарные кавычки - многострочный комментарий.

* Перевод строки:

```
 \n
 ```

* Умножение строк:

```
 'hello!' * 3 = 'Hello! Hello! Hello!
```

* Сложение строк ***"конкатенация"***:

```
'Hello' + 'Hello'
```

У конкатенации есть альтернатива — ***"интерполяция"***. Вот как это выглядит:

```
first_name = 'Joffrey'
greeting = 'Hello'

print(f'{greeting}, {first_name}!')

Hello, Joffrey!
```

Буква ***f*** указывает на то, что мы создаем ***f-строку*** — шаблон, в который с помощью фигурных скобок подставляются значения переменных. На выходе получается обычная строка.

* Сравнение строк:

```
'qwerty' == 'qwerty' - True
'qwerty' <= 'qwerty' - True
'qwerty' => 'qwerty' - True
'qwerty' < 'qwerty'  - False
```

Проверяется длина строки по коду буквы. У каждого символа есть свой код.

* Декодирование:

```
.encode() utf8(консольная кодировка) -> unicode префикс b
.decode(можно указать кодировку) -> операция наоборот
```

* Индексация строк производится квадратными скобками:

```
Вычисление символа: 
 'Qwerty'[0] -> Q
 'qwErty'[2] -> E
 'qwerty'[-1] -> последний символ с конца
 'qwerty'[-2] -> второй символ с конца
 'qwerty'[2:4] ->  вырезаем 'er'
 'qwerty'[2:-1] -> 'ert' (не включительно [2:-1])
 'qwerty'[-3:-1] -> 'rt'
 'qwerty'[:4] -> qwer    [:4] = [0:4] от начала
                          [4:]         до конца
  с начала и до конца, вся строка  [:]
```

* Вывод наоборот:

```
 'qwerty'[::-1] -> 'ytrewq'
```

* Нарезка символов:

```
 [0(начало):20(конец):2(шаг)]
```

* Длина строки:

```
 len('строка') -> 6
```

Переменные - ссылки на некие объекты, которые лежат в оперативной памяти.
Это ссылочное значение.

```
car = 'Toyota Rav4'
car - ссылка 
'Toyota Rav4' - объект в оперативной памяти.
```

Название переменных должно быть латинскими буквами, цифрами и подчерками.

Начинаться должно с маленькой буквы в нижнем регистре, с цифры нельзя:

```
  toyota_rav4
```

* Множественное присвоение(инициализация):

```
х = y = z = 0     
car = rav = 'Toyota Rav4'               - один объект

my_car, my_bike = "Toyota RAV4", "BMW"  - разные объекты
```

* Динамическая типизация - переменная может ссылаться на разные объекты

Определить что в переменной можно через функцию type(name)

Функция isinstance() определение объекта isinstance(x, int) -> true
Функция id(name) -> проверка уникального id объекта
           5678568

### Организация программ

Файл проекта имеет расширение  .py

* Вывод на консоль:

```
print()
```

* Ввод с консоли:

```
user_input = input('Введите координаты: ')
```

* Ввод с консоли нескольких чисел:

```
x, y = map(int, input().split())  ввели координаты
print(type(x)) проверка типа данных
print(x, y)    вывод результата
```

### Методы строк

Длина строки:

```
len()
```

* Поиск в строке

```
.find()   с начала строки
.rfind()  с конца строки

rav4 = 'Toyota'

Input:  rav4.find('a')
Output: 5
```

* Замена в строке:

```
.replace()

Input:  rav4.replace('a', 'b')
Output: Toyotb
```

* Улучшение строк:

```
.lower()     всё к нижнему регистру
.uplower()   всё к верхнему регистру
.strip()
```

* Проверки строк:

```
.isalpha()   все ли символы в строке являются буквами
.isnumeric() все ли символы в строке являются числовые
```

### Списки

Список это некий составной упорядоченный объект, который хранит ссылки на другие объекты и переменные.

Список создается с помощью квадратных скобок:

* пустой список

```
my_list = []
```

* заполненный список

```
my_list = [1, 2, 3, 4, 5]
```

* заполненный список разными типами данных

```
my_list = [1, 2, 3, 'qwerty', 4, 5, rav4]
```

Все операции для строк подходят и для списков.

### Операции со списками

* Добавление к списку:

```
my_list.append(значение) добавляет в конец списка
my_list + [6, 7, 8, 9]
```

* Расширение списка:

```
my_list.extend([элементы]) расширяет в конец списка

my_list.insert([место, элементы]) расширяет в конкретное место списка
```

* Получение объекта из списка:

```
my_list[элемент]
```

* Удаление из списка:

```
my_list.remove(элемент) удаляет конкретный повторяющийся

del my_list[элемент]
```

* Проверка есть ли элемент в списке

```
f = [1, 2, 3, 4]
print(f)
print(2 in f)     - true
print(not 2 in f) - false
```

* Список списков:

```
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(matrix[1][1]) -> 5
```

Сравнение списков так же как сравнение строк.

Сначала сравнение длины, потом поэлементно.

* Проверка вхождения в список:

```
элемент in my_lict
True or False
```

```
id (my_list)
```

### Управляющие конструкции

if:

```
if condition:
    # operator 1
    # operator 2
    # ...
    # operator n
else:
    # operator n + 1
    # operator n + 2
    # ...
    # operator n + m
```

пример:

```
username = input('Введите имя: ')
if(username == 'Маша'):
    print('Ура, это же МАША!');
else:
    print('Привет, ', username);
```

if-else:

```
if condition1:
    # operator
elif condition2:
    # operator
elif condition3:
    # operator
else:
    # operator
```

пример:

```
username = input('Введите имя: ')
if username == 'Маша':
    print('Ура, это же МАША!')
elif username == 'Марина':
    print('Я так ждала Вас, Марина!')
elif username == 'Ильнар':
    print('Ильнар - топ)')
else:
    print('Привет, ', username)
```
